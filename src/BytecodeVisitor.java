import java.util.ArrayList;
import java.util.Stack;

import org.antlr.v4.runtime.ParserRuleContext;


/**
 * This class is responsible for generating bytecode for the MiniJava compiler.
 * It visits the parse tree generated by the MiniJava parser and generates bytecode instructions.
 * It uses the BytecodeGenerator class to emit bytecode instructions.
 * It also uses the Environment class to manage the symbol table, constant pool and variable pool.
 * The design philosophy of mataining the evaluation stack is that:
 * 1. At the end of each expression, the stack should contain the result of the expression.
 * 2. At the end of each statement, the stack should be empty.
 */
public class BytecodeVisitor extends MiniJavaParserBaseVisitor<Void> {
    // The environment is used to manage the symbol table, constant pool and variable pool.
    private final Environment environment;
    // The bytecode generator is used to emit bytecode instructions.
    private final BytecodeGenerator bytecodeGenerator;
    // The semantics visitor is used to get the type of a `ParserRuleContext`.
    private final SemanticsVisitor semanticsVisitor;

    public BytecodeVisitor(BytecodeGenerator bytecodeGenerator, Environment environment, SemanticsVisitor semanticsVisitor) {
        this.bytecodeGenerator = bytecodeGenerator;
        this.environment = environment;
        this.semanticsVisitor = semanticsVisitor;
    }

    // The break and continue stacks are used to manage the break and continue statements in loops.
    // They are used to store the labels for the break and continue statements.
    // when we meet a break or continue statement, we pop the label from the stack and emit a jump instruction to the label.
    private Stack<Integer> breakStack = new Stack<>();
    private Stack<Integer> continueStack = new Stack<>();


    private boolean isConditionExp(MiniJavaParser.ExpressionContext ctx) {
        if (ctx.bop != null) {
            if (ctx.bop.getType() == MiniJavaParser.AND
                    || ctx.bop.getType() == MiniJavaParser.OR
                    || ctx.bop.getType() == MiniJavaParser.EQUAL
                    || ctx.bop.getType() == MiniJavaParser.NOTEQUAL
                    || ctx.bop.getType() == MiniJavaParser.LT
                    || ctx.bop.getType() == MiniJavaParser.LE
                    || ctx.bop.getType() == MiniJavaParser.GT
                    || ctx.bop.getType() == MiniJavaParser.GE) {
                return true;
            }
        }
        if (ctx.prefix != null) {
            if (ctx.prefix.getType() == MiniJavaParser.BANG) {
                return true;
            }
        }
        return false;
    }

    private boolean isArithmeticAssignExp(int type) {
        return type == MiniJavaParser.ASSIGN
                || type == MiniJavaParser.ADD_ASSIGN
                || type == MiniJavaParser.SUB_ASSIGN
                || type == MiniJavaParser.MUL_ASSIGN
                || type == MiniJavaParser.DIV_ASSIGN
                || type == MiniJavaParser.MOD_ASSIGN
                || type == MiniJavaParser.LSHIFT_ASSIGN
                || type == MiniJavaParser.RSHIFT_ASSIGN
                || type == MiniJavaParser.URSHIFT_ASSIGN
                || type == MiniJavaParser.AND_ASSIGN
                || type == MiniJavaParser.OR_ASSIGN
                || type == MiniJavaParser.XOR_ASSIGN;
    }

    private boolean isArithmeticExp(int type) {
        return type == MiniJavaParser.ADD
                || type == MiniJavaParser.SUB
                || type == MiniJavaParser.MUL
                || type == MiniJavaParser.DIV
                || type == MiniJavaParser.MOD
                || type == MiniJavaParser.LSHIFT
                || type == MiniJavaParser.RSHIFT
                || type == MiniJavaParser.URSHIFT
                || type == MiniJavaParser.BITAND
                || type == MiniJavaParser.BITOR
                || type == MiniJavaParser.CARET;
    }

    private boolean isQuestionExp(MiniJavaParser.ExpressionContext ctx) {
        return ctx.bop != null && ctx.bop.getType() == MiniJavaParser.QUESTION;
    }

    // When we need a left value expression, such as an assignment, 
    // in theory only three kinds of expression are valid: identifier, expression [ expression ], expression DOT identifier,
    // but in MiniJava's grammar, the left value may be surrounded by parentheses,
    // so when we need a left value expression, we need get rid of the outer parentheses first.
    private MiniJavaParser.ExpressionContext getLeftValueExp(MiniJavaParser.ExpressionContext ctx) {
        if (ctx.primary() != null) {
            if (ctx.primary().expression() != null) return getLeftValueExp(ctx.primary().expression());
            if (ctx.primary().identifier() != null) return ctx;
        }
        if (ctx.LBRACK() != null) return ctx;
        if (ctx.bop != null && ctx.bop.getType() == MiniJavaParser.DOT) return ctx;
        throw new RuntimeException("Unknown left value expression: " + ctx.getText());
    }
    // This method must be called after `getLeftValueExp`,
    // When we get the three kinds of left value expression: identifier, expression [ expression ], expression DOT identifier,
    // we prepare the left value based on the type of expression.
    private MiniJavaObject prepareLeftValue(MiniJavaParser.ExpressionContext ctx) {
        // identifier
        if (ctx.primary() != null) {
            var id = ctx.primary().identifier().getText();
            var variable = environment.findVariable(id);
            return new MiniJavaObject(new MiniJavaType("primitive", null, 0), variable.index);
        }
        // expression [ expression ]
        else if (ctx.LBRACK() != null) {
            visit(ctx.expression(0));
            visit(ctx.expression(1));
            return new MiniJavaObject(new MiniJavaType(null, null, 1), 1);
        }
        // expression DOT identifier
        else if (ctx.bop != null) {
            visit(ctx.expression(0));
            var id = ctx.identifier().getText();
            var field = environment.newConstant("string", id);
            return new MiniJavaObject(new MiniJavaType(null, "field", 0), field.index);
        } 
        else {
            throw new RuntimeException("Unknown left value expression: " + ctx.getText());
        }
    }

    @Override
    public Void visitCompilationUnit(MiniJavaParser.CompilationUnitContext ctx) {
        var classDecls = ctx.classDeclaration();
        var methodDecls = ctx.methodDeclaration();

        for (var classDecl : classDecls) {
            visitClassDeclaration(classDecl);
        }
        for (var methodDecl : methodDecls) {
            environment.currentClass = "global"; 
            visitMethodDeclaration(methodDecl);
        }
        return null;
    }
    
    @Override
    public Void visitClassDeclaration(MiniJavaParser.ClassDeclarationContext ctx) {
        var className = ctx.identifier().getText();
        environment.currentClass = className;
        bytecodeGenerator.emitBytecode(BytecodeType.OP_CLASS, className);
        environment.clearSymbolTable();
        visitClassBody(ctx.classBody());
        return null;
    }

    @Override
    public Void visitClassBody(MiniJavaParser.ClassBodyContext ctx) {
        if (ctx.classBodyDeclaration() == null) return null;
        environment.newSymbolTable();
        environment.newPools(environment.currentClass);
        var fieldDecls = new ArrayList<ParserRuleContext>();
        var methodDecls = new ArrayList<ParserRuleContext>();
        var constructors = new ArrayList<ParserRuleContext>();

        for (var classBody : ctx.classBodyDeclaration()) {
            if (classBody.fieldDeclaration() != null) 
                fieldDecls.add(classBody.fieldDeclaration());
            else if (classBody.methodDeclaration() != null) 
                methodDecls.add(classBody.methodDeclaration());
            else if (classBody.constructorDeclaration() != null) 
                constructors.add(classBody.constructorDeclaration());
        }

        for (var fieldDecl : fieldDecls) {
            visit(fieldDecl);
        }
        for (var constructor : constructors) {
            visit(constructor);
        }
        for (var methodDecl : methodDecls) {
            visit(methodDecl);
        }

        environment.removeSymbolTable();
        return null;
    }

    @Override
    public Void visitFieldDeclaration(MiniJavaParser.FieldDeclarationContext ctx) {
        var defaultValue = semanticsVisitor.getType(ctx.typeType());
        var declarator = ctx.variableDeclarator();
        var identifier = declarator.identifier().getText();
        // If the variable is not initialized, we need to set a default value
        // to the variable in the symbol table
        if (declarator.variableInitializer() == null) {
            environment.newVariable(defaultValue, identifier);
        } else {
            visit(declarator.variableInitializer());
            var type = semanticsVisitor.getType(declarator.variableInitializer());
            var variable = environment.newVariable(type, identifier);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, variable.index);
        }
        return null;
    }

    @Override
    public Void visitConstructorDeclaration(MiniJavaParser.ConstructorDeclarationContext ctx) {
        var constructorName = ctx.identifier().getText();
        var paramTypes = new ArrayList<MiniJavaType>();
        var params = new ArrayList<MiniJavaObject>();
        if (ctx.formalParameters().formalParameterList() != null) {
            for (var param : ctx.formalParameters().formalParameterList().formalParameter()) {
                var type = semanticsVisitor.getType(param.typeType());
                var id = param.identifier().getText();
                paramTypes.add(new MiniJavaType(type));
                params.add(new MiniJavaObject(type, id));
            }
        }
        var methodSig = new MethodSignature(environment.currentClass, constructorName, paramTypes);
        var methodMangle = methodSig.mangle();
        environment.newMethod(methodMangle, params);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_METHOD, methodMangle);
        visit(ctx.constructorBody);
        return null;
    }

    // When we visit a method declaration,
    // 1. Extract the method name, parameter types, and return type.
    // 2. Create a new method signature and mangle it for unique identification.
    // 3. Initialize a new method environment with the method's parameters.
    // 4. Emit bytecode to define the method.
    // 5. Visit the method body to generate bytecode for its contents.
    @Override
    public Void visitMethodDeclaration(MiniJavaParser.MethodDeclarationContext ctx) {
        var methodName = ctx.identifier().getText();
        var paramTypes = new ArrayList<MiniJavaType>();
        var params = new ArrayList<MiniJavaObject>();
        if (ctx.formalParameters().formalParameterList() != null) {
            for (var param : ctx.formalParameters().formalParameterList().formalParameter()) {
                var type = semanticsVisitor.getType(param.typeType());
                var id = param.identifier().getText();
                paramTypes.add(new MiniJavaType(type));
                params.add(new MiniJavaObject(type, id));
            }
        }
        var methodSig = new MethodSignature(environment.currentClass, methodName, paramTypes);
        var methodMangle = methodSig.mangle();
        environment.newMethod(methodMangle, params);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_METHOD, methodMangle);
        visit(ctx.methodBody);
        return null;
    }

    // To support variable shadowing, we need to create a new symbol table for each block.
    @Override
    public Void visitBlock(MiniJavaParser.BlockContext ctx) {
        environment.newSymbolTable();
        visitChildren(ctx);
        environment.removeSymbolTable();
        return null;
    }

    // To make sure the evaluation stack is empty after each statement,
    // we need to pop the stack after each statement.
    // Specifically, we emit a POP instruction after each SEMI statement in practice.
    @Override
    public Void visitBlockStatement(MiniJavaParser.BlockStatementContext ctx) {
        if (ctx.localVariableDeclaration() != null) {
            visit(ctx.localVariableDeclaration());
            bytecodeGenerator.emitBytecode(BytecodeType.OP_POP);
            return null;
        } else {
            return visit(ctx.statement());
        }
    }

    @Override
    public Void visitArrayInitializer(MiniJavaParser.ArrayInitializerContext ctx) {
        var initializers = ctx.variableInitializer();
        // If initializer is null, which means {}, return a empty array.
        if (initializers == null) {
            var arraySize = environment.newConstant("int", 0);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, arraySize.index);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_NEW_ARRAY);
            return null;
        }
        var size = initializers.size();
        // Create a new array of the given size
        var arraySize = environment.newConstant("int", size);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, arraySize.index); // { size }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_NEW_ARRAY); // { array[size] }
        for (var i = 0; i < size; i++) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_DUP); // { array[size], array[size] }
            var index = environment.newConstant("int", i);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, index.index); // { array[size], array[size], i }
            visit(initializers.get(i)); // { array[size], array[size], i, initializer }
            bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_INDEX); // { array[size], array[i] }
            bytecodeGenerator.emitBytecode(BytecodeType.OP_POP); // { array[size] }
        }
        return null;
    }

    @Override
    public Void visitVariableInitializer(MiniJavaParser.VariableInitializerContext ctx) {
        if (ctx.expression() != null) {
            return visit(ctx.expression());
        } else if (ctx.arrayInitializer() != null) {
            return visit(ctx.arrayInitializer());
        } else {
            throw new RuntimeException("Unknown variable initializer: " + ctx.getText());
        }
    }

    @Override
    public Void visitLocalVariableDeclaration(MiniJavaParser.LocalVariableDeclarationContext ctx) {
        // typeType variableDeclarator
        if (ctx.VAR() == null) {
            var defaultValue = semanticsVisitor.getType(ctx.typeType());
            var declarator = ctx.variableDeclarator();
            var identifier = declarator.identifier().getText();
            // If the variable is not initialized, we need to set a default value
            // to the variable in the symbol table
            if (declarator.variableInitializer() == null) {
                environment.newVariable(defaultValue, identifier);
            } else {
                visit(declarator.variableInitializer());
                var type = semanticsVisitor.getType(declarator.variableInitializer());
                var variable = environment.newVariable(type, identifier);
                bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, variable.index);
            }
            return null;
        }
        // VAR identifier '=' expression
        else {
            var identifier = ctx.identifier().getText();
            var type = semanticsVisitor.getType(ctx.expression());
            visit(ctx.expression());
            var variable = environment.newVariable(type, identifier);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, variable.index);
            return null;
        }
    }

    private Void visitIfStatement(MiniJavaParser.StatementContext ctx) {
        if (ctx.ELSE() == null) {
            Integer true_label = environment.newLabel();
            Integer end_label = environment.newLabel();
            // visit the condition expression, if true, jump to true_label, else jump to end_label
            visitConditionExp(ctx.parExpression().expression(), true_label, end_label);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, true_label);
            visit(ctx.statement(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, end_label);
        } else {
            // If there is an else statement, we need to generate three labels:
            // 1. true_label: the label for the true branch
            // 2. false_label: the label for the false branch
            // 3. end_label: the label for the end of the if statement
            Integer true_label = environment.newLabel();
            Integer false_label = environment.newLabel();
            Integer end_label = environment.newLabel();
            visitConditionExp(ctx.parExpression().expression(), true_label, false_label);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, true_label);
            visit(ctx.statement(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, end_label);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, false_label);
            visit(ctx.statement(1));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, end_label);
        }
        return null;
    }

    private Void visitWhileStatement(MiniJavaParser.StatementContext ctx) {
        // while ( parExpression ) statement

        // Generate labels for the loop:
        Integer start_label = environment.newLabel(); // Loop condition check label
        Integer true_label = environment.newLabel(); // Label for entering the loop body
        Integer end_label = environment.newLabel(); // Label for loop exit

        // Push the current loop's labels onto the stacks
        breakStack.push(end_label);
        continueStack.push(start_label);

        // Emit label for the start of the loop (condition evaluation)
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, start_label);
        // Evaluate the condition: if true, jump to true_label; if false, jump to
        // end_label.
        visitConditionExp(ctx.parExpression().expression(), true_label, end_label);
        // Emit label for the loop body (true branch)
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, true_label);
        // Process the loop body
        visit(ctx.statement(0));
        // After executing the body, jump back to the condition evaluation
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, start_label);
        // Emit the loop exit label
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, end_label);

        // Pop loop labels off the stacks
        breakStack.pop();
        continueStack.pop();

        return null;
    }

    private Void visitForStatement(MiniJavaParser.StatementContext ctx) {
        // for ( forControl ) statement

        environment.newSymbolTable();

        // Process initialization (if present)
        var forInit = ctx.forControl().forInit();
        if (forInit != null)
            visit(forInit);

        // Generate labels:
        Integer start_label = environment.newLabel(); // Condition check label (also used for continue)
        Integer true_label = environment.newLabel(); // Label for entering loop body
        Integer end_label = environment.newLabel(); // Exit label for break

        // Push the loop labels
        breakStack.push(end_label);
        continueStack.push(start_label);

        // Emit label for condition evaluation
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, start_label);

        // Evaluate the loop condition if present; if not, always true
        if (ctx.forControl().expression() != null) {
            visitConditionExp(ctx.forControl().expression(), true_label, end_label);
        } else {
            // No condition means always jump to the body
            bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, true_label);
        }

        // Emit label for loop body
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, true_label);
        // Process the loop body
        visit(ctx.statement(0));

        // Process update expression(s) if present (forUpdate is an expressionList)
        if (ctx.forControl().forUpdate != null) {
            visit(ctx.forControl().forUpdate);
        }
        // Jump back to condition check
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, start_label);
        // Emit loop exit label
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, end_label);

        // Pop the loop labels off the stacks
        breakStack.pop();
        continueStack.pop();

        environment.removeSymbolTable();

        return null;
    }

    private Void visitContinueStatement(MiniJavaParser.StatementContext ctx) {
        if (continueStack.isEmpty())
            throw new RuntimeException("Continue statement not within a loop");
        // Emit a jump to the current loop's continue target (condition check)
        int continue_target = continueStack.peek();
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, continue_target);
        return null;
    }

    private Void visitBreakStatement(MiniJavaParser.StatementContext ctx) {
        if (breakStack.isEmpty())
            throw new RuntimeException("Break statement not within a loop");
        // Emit a jump to the current loop's break target (loop exit)
        int break_target = breakStack.peek();
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, break_target);
        return null;
    }

    // The return value is pushed to the stack before the return statement 
    private Void visitReturnStatement(MiniJavaParser.StatementContext ctx) {
        if (ctx.expression() != null) {
            visit(ctx.expression());
            bytecodeGenerator.emitBytecode(BytecodeType.OP_RETURN);
        } else {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_RETURN);
        }
        return null;
    }

    @Override
    public Void visitStatement(MiniJavaParser.StatementContext ctx) {
        if (ctx.block() != null) {
            return visitChildren(ctx);
        } else if (ctx.IF() != null) {
            return visitIfStatement(ctx);
        } else if (ctx.FOR() != null) {
            return visitForStatement(ctx);
        } else if (ctx.WHILE() != null) {
            return visitWhileStatement(ctx);
        } else if (ctx.CONTINUE() != null) {
            return visitContinueStatement(ctx);
        } else if (ctx.BREAK() != null) {
            return visitBreakStatement(ctx);
        } else if (ctx.RETURN() != null) {
            return visitReturnStatement(ctx);
        } else if (ctx.expression() != null) {
            visit(ctx.expression());
            // Meet SEMI, emit POP the make sure the evaluation stack is empty
            bytecodeGenerator.emitBytecode(BytecodeType.OP_POP);
            return null;
        } else if (ctx.SEMI() != null && ctx.getChildCount() == 1) {
            return visitChildren(ctx);
        } else {
            throw new RuntimeException("Unknown statement: " + ctx.getText());
        }
    }

    // When visit arithmetic expression, we prepare the left expression first,
    // then right expression, and emit the bytecode for the operation.
    private Void visitArithmeticExp(MiniJavaParser.ExpressionContext ctx) {
        visit(ctx.expression(0));
        visit(ctx.expression(1));
        switch (ctx.bop.getType()) {
            case MiniJavaParser.ADD:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_ADD);
                return null;
            case MiniJavaParser.SUB:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_SUB);
                return null;
            case MiniJavaParser.MUL:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_MUL);
                return null;
            case MiniJavaParser.DIV:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_DIV);
                return null;
            case MiniJavaParser.MOD:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_MOD);
                return null;
            case MiniJavaParser.LSHIFT:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_LSHIFT);
                return null;
            case MiniJavaParser.RSHIFT:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_RSHIFT);
                return null;
            case MiniJavaParser.URSHIFT:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_URSHIFT);
                return null;
            case MiniJavaParser.BITAND:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_AND);
                return null;
            case MiniJavaParser.BITOR:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_OR);
                return null;
            case MiniJavaParser.CARET:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_XOR);
                return null;
            default:
                return null;
        }
    }

    // When visit arithmetic assign expression, we divide it into two parts:
    // 1. prepare the left value for assignment, e.g. identifier, expression [ expression ], expression DOT identifier
    // 2. calculate the arithmetic expression and assign the result to the left value
    private Void visitArithmeticAssign(MiniJavaParser.ExpressionContext ctx) {
        var leftExp = getLeftValueExp(ctx.expression(0));
        var object = prepareLeftValue(leftExp);
        if (ctx.bop.getType() == MiniJavaParser.ASSIGN) {
            visit(ctx.expression(1));
            bytecodeGenerator.setVariable(object);
            return null;
        }
        visit(ctx.expression(0));
        visit(ctx.expression(1));
        switch (ctx.bop.getType()) {
            case MiniJavaParser.ADD_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_ADD);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.SUB_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_SUB);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.MUL_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_MUL);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.DIV_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_DIV);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.MOD_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_MOD);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.LSHIFT_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_LSHIFT);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.RSHIFT_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_RSHIFT);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.URSHIFT_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_URSHIFT);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.AND_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_AND);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.OR_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_OR);
                bytecodeGenerator.setVariable(object);
                return null;
            case MiniJavaParser.XOR_ASSIGN:
                bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_XOR);
                bytecodeGenerator.setVariable(object);
                return null;
            default:
                return null;
        }
    }

    private Void visitBopExp(MiniJavaParser.ExpressionContext ctx) {
        if (isArithmeticExp(ctx.bop.getType())) {
            return visitArithmeticExp(ctx);
        } else if (isArithmeticAssignExp(ctx.bop.getType())) {
            return visitArithmeticAssign(ctx);
        } else {
            throw new RuntimeException("Unknown binary operation: " + ctx.bop.getText());
        }
    }

    // This implementation for postfix operator is somehow inefficient, e.g. for exp++:
    // 1. visit the expression, stack: { exp }
    // 2. prepare left value for assignment, stack: { exp, exp }
    // 3. visit the expression again, stack: { exp, exp, exp }
    // 4. emit the increment operation, stack: { exp, exp, exp + 1 }
    // 5. set the variable, stack: { exp, exp + 1 }
    // 6. pop the stack, stack: { exp }
    // why inefficient? because we visit the expression three times.
    // postfix operator need to update the expression value but return the original value,
    // so we need to visit the expression twice: once for the original value, once for the operation.
    private Void visitPostExp(MiniJavaParser.ExpressionContext ctx) {
        visit(ctx.expression(0));
        var leftExp = getLeftValueExp(ctx.expression(0));
        var object = prepareLeftValue(leftExp);
        visit(ctx.expression(0));
        if (ctx.postfix.getType() == MiniJavaParser.INC) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_INC);
            bytecodeGenerator.setVariable(object);
            return null;
        } else if (ctx.postfix.getType() == MiniJavaParser.DEC) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_DEC);
            bytecodeGenerator.setVariable(object);
            return null;
        }
        return null;
    }

    // prefix operator is simpler than postfix operator,
    // we just need to prepare the left value for assignment,
    // visit the expression, emit the operation, and set the variable.
    private Void visitPrefixExp(MiniJavaParser.ExpressionContext ctx) {
        if (ctx.prefix.getType() == MiniJavaParser.INC) {
            var leftExp = getLeftValueExp(ctx.expression(0));
            var object = prepareLeftValue(leftExp);
            visit(ctx.expression(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_INC);
            bytecodeGenerator.setVariable(object);
            return null;
        } else if (ctx.prefix.getType() == MiniJavaParser.DEC) {
            var leftExp = getLeftValueExp(ctx.expression(0));
            var object = prepareLeftValue(leftExp);
            visit(ctx.expression(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_DEC);
            bytecodeGenerator.setVariable(object);
            return null;
        } else if (ctx.prefix.getType() == MiniJavaParser.TILDE) {
            visit(ctx.expression(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_BIT_NOT);
            return null;
        } else if (ctx.prefix.getType() == MiniJavaParser.ADD) {
            visit(ctx.expression(0));
            return null;
        } else if (ctx.prefix.getType() == MiniJavaParser.SUB) {
            visit(ctx.expression(0));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_NEG);
            return null;
        } else {
            throw new RuntimeException("Unknown prefix expression: " + ctx.prefix.getText());
        }
    }

    // To support short circuit evaluation, we need to use true label and false label to control the flow of the program.
    // We introduce new bytecode for conditional jump: OP_JUMP_IF_TRUE and OP_JUMP_IF_FALSE.
    private void visitConditionExp(MiniJavaParser.ExpressionContext ctx, Integer true_label, Integer false_label) {
        if (ctx.bop != null) {
            if (ctx.bop.getType() == MiniJavaParser.AND) {
                Integer label = environment.newLabel();
                visitConditionExp(ctx.expression(0), label, false_label);
                bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, label);
                visitConditionExp(ctx.expression(1), true_label, false_label);
            } else if (ctx.bop.getType() == MiniJavaParser.OR) {
                Integer label = environment.newLabel();
                visitConditionExp(ctx.expression(0), true_label, label);
                bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, label);
                visitConditionExp(ctx.expression(1), true_label, false_label);
            } else {
                // Exp -> Exp RELOP Exp
                visit(ctx.expression(0));
                visit(ctx.expression(1));
                switch (ctx.bop.getType()) {
                    case MiniJavaParser.EQUAL:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_EQ);
                        break;
                    case MiniJavaParser.NOTEQUAL:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_NEQ);
                        break;
                    case MiniJavaParser.LT:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_LT);
                        break;
                    case MiniJavaParser.LE:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_LE);
                        break;
                    case MiniJavaParser.GT:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_GT);
                        break;
                    case MiniJavaParser.GE:
                        bytecodeGenerator.emitBytecode(BytecodeType.OP_GE);
                        break;
                }
                bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP_IF_TRUE, true_label);
                bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, false_label);
            }
        } else if (ctx.prefix != null) {
            // Exp -> !Exp
            visitConditionExp(ctx.expression(0), false_label, true_label);
        } else {
            throw new RuntimeException("Unknown condition expression: " + ctx.getText());
        }
    }

    // This method handles conditional expressions (e.g., logical AND, OR, etc.).
    // It uses true and false labels to implement short-circuit evaluation.
    // Initially, a false value is pushed onto the stack.
    // If the condition evaluates to true, the false value is popped, and a true value is pushed instead.
    private Void visitConditionalExp(MiniJavaParser.ExpressionContext ctx) {
        Integer true_label = environment.newLabel();
        Integer false_label = environment.newLabel();
        bytecodeGenerator.emitBytecode(BytecodeType.OP_FALSE);
        visitConditionExp(ctx, true_label, false_label);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, true_label);
        // Pop out the False value
        bytecodeGenerator.emitBytecode(BytecodeType.OP_POP);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_TRUE);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, false_label);
        return null;
    }


     // The method processes the conditional expression in the following steps:
     // 1. Evaluates the condition (first expression) and emits a jump instruction
     //     to the false label if the condition evaluates to false.
     // 2. Emits bytecode for the true branch (second expression) and jumps to the end label.
     // 3. Emits the false label and generates bytecode for the false branch (third expression).
     // 4. Emits the end label to mark the end of the conditional expression.
    private Void visitQuestionExp(MiniJavaParser.ExpressionContext ctx) {
        Integer false_label = environment.newLabel();
        Integer end_label = environment.newLabel();
        visitExpression(ctx.expression(0));
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP_IF_FALSE, false_label);
        // True expression
        visitExpression(ctx.expression(1));
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, end_label);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, false_label);
        // False expression
        visitExpression(ctx.expression(2));
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, end_label);
        return null;
    }

    // exp [ exp ]
    private Void visitArrayIndex(MiniJavaParser.ExpressionContext ctx) {
        visit(ctx.expression(0));
        visit(ctx.expression(1));
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_INDEX);
        return null;
    }

    private Void arrayCreator(MiniJavaParser.CreatorContext ctx, int curDim) {
        var rest = ctx.arrayCreatorRest();
        var expList = rest.expression();

        int providedDims = expList.size();
        int totalDims = rest.LBRACK().size();

        // If we are at a dimension without a size expression
        if (curDim >= providedDims) {
            if (providedDims != totalDims || ctx.createdName().identifier() != null) {
                // Push null for not fully initialized arrays: int[3][] or class arrays: MyClass[3]
                bytecodeGenerator.emitBytecode(BytecodeType.OP_NIL); // stack: { null }
                return null;
            } else {
                // Handle default values for primitive types
                var type = ctx.createdName().primitiveType().getText();
                var primitive = MiniJavaType.newPrimitiveType(type);
                if (primitive.isInt()) {
                    var defaultInt = environment.newConstant("int", 0);
                    bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, defaultInt.index); // stack: { 0 }
                    return null;
                } else if (primitive.isBoolean()) {
                    var defaultBool = environment.newConstant("boolean", false);
                    bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, defaultBool.index); // stack: { false }
                    return null;
                } else if (primitive.isChar()) {
                    var defaultChar = environment.newConstant("char", '\0');
                    bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, defaultChar.index); // stack: { '\0' }
                    return null;
                } else if (primitive.isString()) {
                    var defaultString = environment.newConstant("string", "");
                    bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, defaultString.index); // stack: { "" }
                    return null;
                }
                throw new RuntimeException("Unknown primitive type: " + type);
            }
        }

        // Visit the current dimension size expression
        visit(expList.get(curDim)); // stack: { size }
        var sizeVar = environment.newTemp();
        // Store the size in a temporary variable
        bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, sizeVar.index); // stack: {}
        // Create a new array of the given size
        bytecodeGenerator.emitBytecode(BytecodeType.OP_NEW_ARRAY); // stack: { array }
        var arrayVar = environment.newTemp();
        // Store the array in a temporary variable
        bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, arrayVar.index); // stack: {}
        bytecodeGenerator.emitBytecode(BytecodeType.OP_POP); // stack: {}

        // Initialize the index variable to 0
        var indexVar = environment.newTemp();
        var defaultValue = environment.newConstant("int", 0);
        bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, defaultValue.index); // stack: { 0 }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, indexVar.index); // stack: {}
        bytecodeGenerator.emitBytecode(BytecodeType.OP_POP); // stack: {}

        // Start of the loop
        var loopStart = environment.newLabel();
        var loopEnd = environment.newLabel();

        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, loopStart); // stack: {}
        // Load index and size for comparison
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, indexVar.index); // stack: { index }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, sizeVar.index); // stack: { index, size }
        // Check if index >= size
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GE); // stack: { index >= size }
        // If true, jump to the end of the loop
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP_IF_TRUE, loopEnd); // stack: {}

        // Load the array and index for assignment
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, arrayVar.index); // stack: { array }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, indexVar.index); // stack: { array, index }
        // Recursively create subarrays
        arrayCreator(ctx, curDim + 1); // stack: { array, index, subArray }
        // Assign the subarray to the current index
        bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_INDEX); // stack: {}
        bytecodeGenerator.emitBytecode(BytecodeType.OP_POP); // stack: {}

        // Increment the index variable
        bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, indexVar.index); // stack: { index }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_INC); // stack: { index + 1 }
        bytecodeGenerator.emitBytecode(BytecodeType.OP_SET_LOCAL, indexVar.index); // stack: {}
        bytecodeGenerator.emitBytecode(BytecodeType.OP_POP); // stack: {}

        // Jump back to the start of the loop
        bytecodeGenerator.emitBytecode(BytecodeType.OP_JUMP, loopStart); // stack: {}
        // End of the loop
        bytecodeGenerator.emitBytecode(BytecodeType.OP_LABEL, loopEnd); // stack: {}

        return null;
    }

    private Void visitArrayCreator(MiniJavaParser.CreatorContext ctx) {
        var rest = ctx.arrayCreatorRest();
        if (rest.arrayInitializer() != null) {
            return visit(rest.arrayInitializer());
        }
        else return arrayCreator(ctx, 0);
    }

    private Void visitClassCreator(MiniJavaParser.CreatorContext ctx) {
        var paramTypes = new ArrayList<MiniJavaType>();
        if (ctx.classCreatorRest().expressionList() != null)
            for (var exp : ctx.classCreatorRest().expressionList().expression()){
                visit(exp);
                var arg = semanticsVisitor.getType(exp);
                paramTypes.add(arg);
            }
        var methodName = environment.newConstant("string", semanticsVisitor.getMangledMethod(ctx)); 
        bytecodeGenerator.emitBytecode(BytecodeType.OP_CALL, methodName.index, paramTypes.size());
        return null;
    }

    @Override
    public Void visitCreator(MiniJavaParser.CreatorContext ctx) {
        if (ctx.arrayCreatorRest() != null) return visitArrayCreator(ctx);
        else return visitClassCreator(ctx);
    }

    // When meet a method call:
    // 1. visit the arguments and push them to the stack
    // 2. emit the bytecode for the method call
    // Note that about method overloading, we handle it in the semantics visitor.
    // So we just get the right mangled method name from the semantics visitor,
    // and emit the bytecode for the method call.
    @Override
    public Void visitMethodCall(MiniJavaParser.MethodCallContext ctx) {
        var argumentTypes = new ArrayList<MiniJavaType>();
        if (ctx.arguments().expressionList() != null) {
            for (var exp : ctx.arguments().expressionList().expression()) {
                visit(exp);
                var arg = semanticsVisitor.getType(exp);
                argumentTypes.add(arg);
            }
        }
        var methodName = environment.newConstant("string", semanticsVisitor.getMangledMethod(ctx));
        bytecodeGenerator.emitBytecode(BytecodeType.OP_CALL, methodName.index, argumentTypes.size());
        return null;
    }

    private Void visitClassMethodCall(MiniJavaParser.MethodCallContext ctx, String className, boolean isDotMethodCall) {
        var argumentTypes = new ArrayList<MiniJavaType>();
        if (ctx.arguments().expressionList() != null) {
            for (var exp : ctx.arguments().expressionList().expression()) {
                visit(exp);
                var arg = semanticsVisitor.getType(exp);
                argumentTypes.add(arg);
            }
        }
        if (isDotMethodCall) {
            var methodSig = new MethodSignature(className, ctx.identifier().getText(), argumentTypes);
            var methodName = environment.newConstant("string", methodSig.mangle());
            bytecodeGenerator.emitBytecode(BytecodeType.OP_INVOKE, methodName.index, argumentTypes.size());
        } else {
            var methodName = environment.newConstant("string", semanticsVisitor.getMangledMethod(ctx));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CALL, methodName.index, argumentTypes.size());
        }
        return null;
    }

    private Void visitDotExp(MiniJavaParser.ExpressionContext ctx) {
        var expType = semanticsVisitor.getType(ctx.expression(0));
        visit(ctx.expression(0));
        if (ctx.identifier() != null) {
            var field = environment.newConstant("string", ctx.identifier().getText());
            bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_FIELD, field.index);
        } else {
            visitClassMethodCall(ctx.methodCall(), expType.classType, true);
        }
        return null;
    }

    @Override
    public Void visitExpression(MiniJavaParser.ExpressionContext ctx) {
        if (ctx.LBRACK() != null) {
           return visitArrayIndex(ctx);
        } else if (ctx.creator() != null) { 
            return visit(ctx.creator());
        } else if (ctx.bop != null && ctx.bop.getType() == MiniJavaParser.DOT) {
            return visitDotExp(ctx);
        } else if (ctx.methodCall() != null) {
            return visitClassMethodCall(ctx.methodCall(), environment.currentClass,false);
        } else if (isConditionExp(ctx)) {
           return visitConditionalExp(ctx);
        } else if (isQuestionExp(ctx)) {
            return visitQuestionExp(ctx);
        } else if (ctx.bop != null) {
            return visitBopExp(ctx);
        } else if (ctx.primary() != null) {
            return visit(ctx.primary());
        } else if (ctx.postfix != null) {
            return visitPostExp(ctx);
        } else if (ctx.prefix != null) {
            return visitPrefixExp(ctx);
        } else if (ctx.typeType() != null) {
            visit(ctx.expression(0));
            var toType = environment.newConstant("string", ctx.typeType().getText());
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CAST, toType.index);
            return null;
        } else {
            throw new RuntimeException("Unknown expression: " + ctx.getText());
        }
    }

    @Override
    public Void visitPrimary(MiniJavaParser.PrimaryContext ctx) {
        if (ctx.expression() != null) return visit(ctx.expression());
        else if (ctx.THIS() != null) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_THIS);
            return null;
        }
        else if (ctx.SUPER() != null) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_SUPER);
            return null;
        }
        else if (ctx.identifier() != null) {
            return visit(ctx.identifier());
        }
        else if (ctx.literal() != null) {
            return visit(ctx.literal());
        }
        else throw new RuntimeException("Unknown primary: " + ctx.getText());
    }


    // This method handles various types of literals,
    // including integers, strings, booleans, characters, and null values.
    @Override
    public Void visitLiteral(MiniJavaParser.LiteralContext ctx) {
        if (ctx.DECIMAL_LITERAL() != null) {
            // ! Note that in course lab, we support treating decimal literal as char value
            // ! but in this implementation, we don't support it.
            var ret = environment.newConstant("int", Integer.parseInt(ctx.getText()));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, ret.index);
            return null;
        } else if (ctx.STRING_LITERAL() != null) {
            var str = ctx.getText();
            var ret = environment.newConstant("string", str.substring(1, str.length() - 1));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, ret.index);
            return null;
        } else if (ctx.BOOL_LITERAL() != null) {
            var ret = environment.newConstant("boolean", "true".equals(ctx.getText()));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, ret.index);
            return null;
        } else if (ctx.CHAR_LITERAL() != null) {
            var ret = environment.newConstant("char", ctx.getText().charAt(1));
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, ret.index);
            return null;
        } else if (ctx.NULL_LITERAL() != null) {
            var ret = environment.newConstant("null", null);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_CONSTANT, ret.index);
            return null;
        } else {
            throw new RuntimeException("Unknown literal: " + ctx.getText());
        }
    }

    // Find variable in the symbol table,
    // and emit the bytecode for getting the variable.
    // The variable can be a local variable, a field variable, or an array element.
    @Override
    public Void visitIdentifier(MiniJavaParser.IdentifierContext ctx) {
        String identifier = ctx.IDENTIFIER().getText();
        var variable = environment.findVariable(identifier);
        if (variable != null) {
            bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_LOCAL, variable.index);
        } else {
            // If the variable is not found in the local scope, 
            // it must be a field variable.
            var field = environment.newConstant("string", identifier);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_THIS);
            bytecodeGenerator.emitBytecode(BytecodeType.OP_GET_FIELD, field.index);
        }
        return null;
    }
}
